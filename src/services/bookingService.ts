
import { supabase } from "@/integrations/supabase/client";
import { Booking } from "@/types/database";
import { logSupabaseError } from "@/utils/errorLogger";

// Rename and export functions to match the import statements
export async function fetchBookingById(id: string): Promise<Booking> {
  return getBookingById(id);
}

export async function fetchUserBookings(email: string): Promise<Booking[]> {
  return getUserBookings(email);
}

// Create a new booking with improved foreign key constraint handling
export async function createBooking(bookingData: any): Promise<Booking | null> {
  console.log("Creating booking with data:", bookingData);
  
  try {
    // Critical fix: Verify seat_category_id exists before proceeding
    if (!bookingData.seat_category_id) {
      throw new Error("seat_category_id is required for booking");
    }
    
    // First check if the seat category exists
    const { data: categoryCheck, error: categoryError } = await supabase
      .from("seat_categories")
      .select("id, stadium_section_id")
      .eq("id", bookingData.seat_category_id)
      .single();
      
    if (categoryError || !categoryCheck) {
      console.error("Invalid seat category ID:", bookingData.seat_category_id);
      throw new Error(`Invalid seat category ID: ${bookingData.seat_category_id}. Category does not exist.`);
    }
    
    // This is crucial - ensure that section_id is the same as the stadium_section_id from the seat category
    // This keeps both values synchronized and avoids foreign key constraint violations
    const modifiedData = {
      ...bookingData,
      section_id: categoryCheck.stadium_section_id // Use the section_id from the seat category
    };
    
    console.log("Modified booking data with correct section_id:", modifiedData);
    
    // Remove booking_id if it's present as it's auto-generated by the database
    if (modifiedData.booking_id !== undefined) {
      delete modifiedData.booking_id;
    }
    
    // Now proceed with the booking creation
    const { data, error } = await supabase
      .from("bookings")
      .insert(modifiedData)
      .select()
      .single();
      
    if (error) {
      console.error("Error creating booking:", error);
      logSupabaseError(error, "createBooking", { bookingData: modifiedData });
      throw new Error(`Failed to create booking: ${error.message}`);
    }
    
    console.log("Booking created successfully:", data);
    return data;
  } catch (error) {
    console.error("Failed to create booking:", error);
    throw error;
  }
}

// Get booking by ID
export async function getBookingById(id: string): Promise<Booking> {
  console.log("Fetching booking with ID:", id);
  
  try {
    const { data, error } = await supabase
      .from("bookings")
      .select(`
        *,
        match:match_id(
          *,
          team1:team1_id(*),
          team2:team2_id(*),
          stadium:stadium_id(*)
        ),
        seat_category:seat_category_id(*)
      `)
      .eq("id", id)
      .single();
      
    if (error) {
      console.error("Error fetching booking:", error);
      logSupabaseError(error, "getBookingById", { id });
      throw error;
    }
    
    console.log("Booking data returned:", data);
    return data;
  } catch (error) {
    console.error("Failed to fetch booking:", error);
    throw error;
  }
}

// Get bookings by user email
export async function getUserBookings(email: string): Promise<Booking[]> {
  console.log("Fetching bookings for user:", email);
  
  try {
    const { data, error } = await supabase
      .from("bookings")
      .select(`
        *,
        match:match_id(
          *,
          team1:team1_id(*),
          team2:team2_id(*),
          stadium:stadium_id(*)
        ),
        seat_category:seat_category_id(*)
      `)
      .eq("user_email", email)
      .order("created_at", { ascending: false });
      
    if (error) {
      console.error("Error fetching user bookings:", error);
      logSupabaseError(error, "getUserBookings", { email });
      throw error;
    }
    
    console.log("User bookings returned:", data);
    return data || [];
  } catch (error) {
    console.error("Failed to fetch user bookings:", error);
    throw error;
  }
}

// Update booking status
export async function updateBookingStatus(id: string, status: string): Promise<void> {
  console.log(`Updating booking ${id} status to ${status}`);
  
  try {
    const { error } = await supabase
      .from("bookings")
      .update({ status })
      .eq("id", id);
      
    if (error) {
      console.error("Error updating booking status:", error);
      logSupabaseError(error, "updateBookingStatus", { id, status });
      throw error;
    }
    
    console.log("Booking status updated successfully");
  } catch (error) {
    console.error("Failed to update booking status:", error);
    throw error;
  }
}
